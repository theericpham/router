Eric's VM IP: 192.168.56.12

sr_router.c

  sr_handlepacket(sr_instance* sr, uint8_t* packet, unsigned int len, char* interface)
    if len < size of ethernet header //I think this check is redundant here -Caleb
      error
      
    if ethernet type is IP
      process as IP packet
    else if ethernet type is ARP
      process as ARP packet
    else
      error
  
  sr_handle_ip_packet(sr_instance* sr, uint8_t* packet, unsigned int len, char* interface)
    if len < size of (ethernet header + IP header)
      ICMP type 12 code 2 bad length
      
    create IP header
    compute checksum on IP header
      if bad, ICMP error?
    
		(call sendIp)
      ...
    else
      Look up next-hop interface in routing table using destination IP address
        if no next-hop interface, send ICMP type 3 code 0, destination network unreachable
     get interface for packet
    if interface belongs to router
      Look up MAC address for next-hop IP in ARP cache
      If next-hop MAC isn't cached,
        send ARP request for it
        add this packet to queue
        
      decrement packet ttl
      if packet ttl becomes 0
        send ICMP type 11 code 0, time exceeded
      recompute checksum
      send packet
      
  sr_handle_arp_packet(sr_instance* sr, uint8_t* packet, unsigned int len, char* interface)
    if len < size of (ethernet header + ARP header)
      error
      
    format ARP header and get interface
    
    if interface not found
      error
      
    if ARP reply
      insert IP to MAC address mapping into cache (returns an ARP request if one exists)
      for all packets waiting on this ARP request
        update packet fields by casting as ethernet header
        set ethernet frame
          destination host address = target MAC
          source host address = source MAC
        return packet
        destroy request
    
    if ARP request
      set ARP header
        destination = source
        source = our interface
        change code from ARP request to ARP reply
      set ethernet frame
        destination host address = target MAC
        source host address = source MAC
      return packet
      
sr_arpcache.c
  sr_arpcache_sweepreqs(sr_instance* sr)
    for each request in cache
      handle ARP request

  sr_handle_arpreq(sr_instace* sr, sr_arpreq*, req)
    if difftime(now, req->sent) > 1.0
        if req->times_sent >= 5:
            send icmp host unreachable to source addr of all pkts waiting on this request
            destroy request
        else:
            send arp request
            req->sent = now
            req->times_sent++
      

sr_icmp.c --> new file
  sr_send_icmp(sr_instance* sr, uint8_t type, uint8_t code, uint32_t dip, uint8_t* payload, char* interface)
    NOTE: why are there 2 structs for icmp and which one do we use?
    
    
/*****************************************/
/**********    HANDLE IP    **************/
/*****************************************/
if len of raw frame < ethernet header + ip header
  return error
  
get the ip header
validate the checksum
check if the ip destination is one of the routers interfaces --> getInterfaceByIp(sr, destination_ip)
if the interface belongs to the router
  if the payload protocol is icmp
    if len of raw frame < ethernet + ip + icmp header
      return error
    get the icmp header
    validate icmp checksum
    if the icmp is an echo request
      format and send an icmp echo reply
  if the payload protocol isn't icmp, then just try to foward the packet
    get the next hop route to the ip destination
    if no route is found, send an icmp host unreachable
    decrement ttl
    if ttl becomes 0, send icmp ttl expired
    recompute checksum
    forward packet
      
